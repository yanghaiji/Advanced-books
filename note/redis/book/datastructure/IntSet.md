## Redis 内部数据结构 ☞ 整数集合

整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。

举个例子， 如果我们创建一个只包含五个元素的集合键， 并且集合中的所有元素都是整数值， 那么这个集合键的底层实现就会是整数集合：

```shell
redis> SADD numbers 1 3 5 7 9
(integer) 5

redis> OBJECT ENCODING numbers
"intset"
```

### 整数集合的实现

整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 `int16_t` 、 `int32_t` 或者 `int64_t` 的整数值， 并且保证集合中不会出现重复元素。

每个 `intset.h/intset` 结构表示一个整数集合：

```
typedef struct intset {

    // 编码方式
    uint32_t encoding;

    // 集合包含的元素数量
    uint32_t length;

    // 保存元素的数组
    int8_t contents[];

} intset;
```

`contents` 数组是整数集合的底层实现： 整数集合的每个元素都是 `contents` 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。

`length` 属性记录了整数集合包含的元素数量， 也即是 `contents` 数组的长度。

虽然 `intset` 结构将 `contents` 属性声明为 `int8_t` 类型的数组， 但实际上 `contents` 数组并不保存任何 `int8_t` 类型的值 —— `contents` 数组的真正类型取决于 `encoding` 属性的值：

- 如果 `encoding` 属性的值为 `INTSET_ENC_INT16` ， 那么 `contents` 就是一个 `int16_t` 类型的数组， 数组里的每个项都是一个 `int16_t` 类型的整数值 （最小值为 `-32,768` ，最大值为 `32,767` ）。
- 如果 `encoding` 属性的值为 `INTSET_ENC_INT32` ， 那么 `contents` 就是一个 `int32_t` 类型的数组， 数组里的每个项都是一个 `int32_t` 类型的整数值 （最小值为 `-2,147,483,648` ，最大值为 `2,147,483,647` ）。
- 如果 `encoding` 属性的值为 `INTSET_ENC_INT64` ， 那么 `contents` 就是一个 `int64_t` 类型的数组， 数组里的每个项都是一个 `int64_t` 类型的整数值 （最小值为 `-9,223,372,036,854,775,808` ，最大值为 `9,223,372,036,854,775,807` ）。

图 6-1 展示了一个整数集合示例：

- `encoding` 属性的值为 `INTSET_ENC_INT16` ， 表示整数集合的底层实现为 `int16_t` 类型的数组， 而集合保存的都是 `int16_t` 类型的整数值。
- `length` 属性的值为 `5` ， 表示整数集合包含五个元素。
- `contents` 数组按从小到大的顺序保存着集合中的五个元素。
- 因为每个集合元素都是 `int16_t` 类型的整数值， 所以 `contents` 数组的大小等于 `sizeof(int16_t) * 5 = 16 * 5 = 80` 位。

![digraph ](img/graphviz-acf7fe010d7b09c5d2500c72eb555863e67ad74f.png)

图 6-2 展示了另一个整数集合示例：

- `encoding` 属性的值为 `INTSET_ENC_INT64` ， 表示整数集合的底层实现为 `int64_t` 类型的数组， 而数组中保存的都是 `int64_t` 类型的整数值。
- `length` 属性的值为 `4` ， 表示整数集合包含四个元素。
- `contents` 数组按从小到大的顺序保存着集合中的四个元素。
- 因为每个集合元素都是 `int64_t` 类型的整数值， 所以 `contents` 数组的大小为 `sizeof(int64_t) * 4 = 64 * 4 = 256` 位。

![digraph ](img/graphviz-878c08b90e7bbd02863d3e5cad116b36785ea30e.png)

虽然 `contents` 数组保存的四个整数值中， 只有 `-2675256175807981027` 是真正需要用 `int64_t` 类型来保存的， 而其他的 `1` 、 `3` 、 `5` 三个值都可以用 `int16_t` 类型来保存， 不过根据整数集合的升级规则， 当向一个底层为 `int16_t` 数组的整数集合添加一个 `int64_t` 类型的整数值时， 整数集合已有的所有元素都会被转换成 `int64_t` 类型， 所以 `contents` 数组保存的四个整数值都是 `int64_t` 类型的， 不仅仅是 `-2675256175807981027` 。

### 升级
每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。

升级整数集合并添加新元素共分为三步进行：

1. 根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。
2. 将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。
3. 将新元素添加到底层数组里面。

举个例子， 假设现在有一个 `INTSET_ENC_INT16` 编码的整数集合， 集合中包含三个 `int16_t` 类型的元素， 如图 6-3 所示。

![](img/graphviz-21955e71222114585926ca37959be5d948b9ad2b.png)

因为每个元素都占用 `16` 位空间， 所以整数集合底层数组的大小为 `3 * 16 = 48` 位， 图 6-4 展示了整数集合的三个元素在这 `48` 位里的位置。

![](img/graphviz-eac3e19de3f8dd9c40f2302c7b2d10e73983cd5c.png)

现在， 假设我们要将类型为 `int32_t` 的整数值 `65535` 添加到整数集合里面， 因为 `65535` 的类型 `int32_t` 比整数集合当前所有元素的类型都要长， 所以在将 `65535` 添加到整数集合之前， 程序需要先对整数集合进行升级。

升级首先要做的是， 根据新类型的长度， 以及集合元素的数量（包括要添加的新元素在内）， 对底层数组进行空间重分配。

整数集合目前有三个元素， 再加上新元素 `65535` ， 整数集合需要分配四个元素的空间， 因为每个 `int32_t` 整数值需要占用 `32` 位空间， 所以在空间重分配之后， 底层数组的大小将是 `32 * 4 = 128` 位， 如图 6-5 所示。

![](img/graphviz-63f486a40c957eb449a5836555915601a1be61d6.png)

虽然程序对底层数组进行了空间重分配， 但数组原有的三个元素 `1` 、 `2` 、 `3` 仍然是 `int16_t` 类型， 这些元素还保存在数组的前 `48` 位里面， 所以程序接下来要做的就是将这三个元素转换成 `int32_t` 类型， 并将转换后的元素放置到正确的位上面， 而且在放置元素的过程中， 需要维持底层数组的有序性质不变。

首先， 因为元素 `3` 在 `1` 、 `2` 、 `3` 、 `65535` 四个元素中排名第三， 所以它将被移动到 `contents` 数组的索引 `2` 位置上， 也即是数组 `64` 位至 `95` 位的空间内， 如图 6-6 所示。

![](img/graphviz-b8d54b0b6f077fd7a618a9fc198350cb3301fe8a.png)

接着， 因为元素 `2` 在 `1` 、 `2` 、 `3` 、 `65535` 四个元素中排名第二， 所以它将被移动到 `contents` 数组的索引 `1` 位置上， 也即是数组的 `32` 位至 `63` 位的空间内， 如图 6-7 所示。

![digraph ](img/graphviz-851e799be7671b59d22c1360c757f70871b1460a.png)

之后， 因为元素 `1` 在 `1` 、 `2` 、 `3` 、 `65535` 四个元素中排名第一， 所以它将被移动到 `contents` 数组的索引 `0` 位置上， 也即是数组的 `0` 位至 `31` 位的空间内， 如图 6-8 所示。

![digraph ](img/graphviz-a6e1fc86a05aa7dab4284dbdb027cedb96a5259a.png)

然后， 因为元素 `65535` 在 `1` 、 `2` 、 `3` 、 `65535` 四个元素中排名第四， 所以它将被添加到 `contents` 数组的索引 `3` 位置上， 也即是数组的 `96` 位至 `127` 位的空间内， 如图 6-9 所示。

![](img/graphviz-c0a4fd52c53de90a8b70888f89c7b39df564fc6b.png)

最后， 程序将整数集合 `encoding` 属性的值从 `INTSET_ENC_INT16` 改为 `INTSET_ENC_INT32` ， 并将 `length` 属性的值从 `3` 改为 `4` ， 设置完成之后的整数集合如图 6-10 所示。

![digraph](img/graphviz-a1be785cf70da6f653415d42642a25931656fe76.png)

因为每次向整数集合添加新元素都可能会引起升级， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的时间复杂度为 O(N) 。

其他类型的升级操作， 比如从 `INTSET_ENC_INT16` 编码升级为 `INTSET_ENC_INT64` 编码， 或者从 `INTSET_ENC_INT32` 编码升级为 `INTSET_ENC_INT64` 编码， 升级的过程都和上面展示的升级过程类似。

升级之后新元素的摆放位置

因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：

- 在新元素小于所有现有元素的情况下， 新元素会被放置在底层数组的最开头（索引 `0` ）；
- 在新元素大于所有现有元素的情况下， 新元素会被放置在底层数组的最末尾（索引 `length-1` ）。

### 升级的好处

整数集合的升级策略有两个好处， 一个是提升整数集合的灵活性， 另一个是尽可能地节约内存。

#### 提升灵活性

因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。

比如说， 我们一般只使用 `int16_t` 类型的数组来保存 `int16_t` 类型的值， 只使用 `int32_t` 类型的数组来保存 `int32_t` 类型的值， 诸如此类。

但是， 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 `int16_t` 、 `int32_t` 或者 `int64_t` 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。

#### 节约内存

当然， 要让一个数组可以同时保存 `int16_t` 、 `int32_t` 、 `int64_t` 三种类型的值， 最简单的做法就是直接使用 `int64_t` 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 `int16_t` 类型或者 `int32_t` 类型的值， 数组都需要使用 `int64_t` 类型的空间去保存它们， 从而出现浪费内存的情况。

而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。

比如说， 如果我们一直只向整数集合添加 `int16_t` 类型的值， 那么整数集合的底层实现就会一直是 `int16_t` 类型的数组， 只有在我们要将 `int32_t` 类型或者 `int64_t` 类型的值添加到集合时， 程序才会对数组进行升级。

### 降级

整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。

举个例子， 对于图 6-11 所示的整数集合来说， 即使我们将集合里唯一一个真正需要使用 `int64_t` 类型来保存的元素 `4294967295` 删除了， 整数集合的编码仍然会维持 `INTSET_ENC_INT64` ， 底层数组也仍然会是 `int64_t` 类型的， 如图 6-12 所示。

![](img/graphviz-66791e1245ddf710a39196b431ac5c90c287c64e.png)

![digraph](img/graphviz-d3355e08bf0d2f1639075046eb80c940da7e5fc5.png)

### 整数集合的操作 API

表 6-1 列出了整数集合的操作 API 。

------

表 6-1 整数集合 API

| 函数            | 作用                             | 时间复杂度                                                   |
| :-------------- | :------------------------------- | :----------------------------------------------------------- |
| `intsetNew`     | 创建一个新的整数集合。           | O(1)                                                         |
| `intsetAdd`     | 将给定元素添加到整数集合里面。   | O(N)                                                         |
| `intsetRemove`  | 从整数集合中移除给定元素。       | O(N)                                                         |
| `intsetFind`    | 检查给定值是否存在于集合。       | 因为底层数组有序，查找可以通过二分查找法来进行， 所以复杂度为 O(\log N) 。 |
| `intsetRandom`  | 从整数集合中随机返回一个元素。   | O(1)                                                         |
| `intsetGet`     | 取出底层数组在给定索引上的元素。 | O(1)                                                         |
| `intsetLen`     | 返回整数集合包含的元素个数。     | O(1)                                                         |
| `intsetBlobLen` | 返回整数集合占用的内存字节数。   | O(1)                                                         |

----

### 重点回顾

- 整数集合是集合键的底层实现之一。
- 整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。
- 升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。
- 整数集合只支持升级操作， 不支持降级操作。

