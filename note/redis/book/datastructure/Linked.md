## Redis 内部数据结构 ☞ 链表

链表提供了高效的节点重排能力， 以及顺序性的节点访问方式， 并且可以通过增删节点来灵活地调整链表的长度。

作为一种常用数据结构， 链表内置在很多高级的编程语言里面， 因为 Redis 使用的 C 语言并没有内置这种数据结构， 所以 Redis 构建了自己的链表实现。

链表在 Redis 中的应用非常广泛， 比如列表键的底层实现之一就是链表： 当一个列表键包含了数量比较多的元素， 又或者列表中包含的元素都是比较长的字符串时， Redis 就会使用链表作为列表键的底层实现。

举个例子， 以下展示的 `integers` 列表键包含了从 `1` 到 `1024` 共一千零二十四个整数：

```
redis> LLEN integers
(integer) 1024

redis> LRANGE integers 0 10
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
7) "7"
8) "8"
9) "9"
10) "10"
11) "11"
```

`integers` 列表键的底层实现就是一个链表， 链表中的每个节点都保存了一个整数值。

除了链表键之外， 发布与订阅、慢查询、监视器等功能也用到了链表， Redis 服务器本身还使用链表来保存多个客户端的状态信息， 以及使用链表来构建客户端输出缓冲区（output buffer）， 本书后续的章节将陆续对这些链表应用进行介绍。

本章接下来的内容将对 Redis 的链表实现进行介绍， 并列出相应的链表和链表节点 API 。

### 链表和链表节点的实现

每个链表节点使用一个 `adlist.h/listNode` 结构来表示：

```
typedef struct listNode {

    // 前置节点
    struct listNode *prev;

    // 后置节点
    struct listNode *next;

    // 节点的值
    void *value;

} listNode;
```

多个 `listNode` 可以通过 `prev` 和 `next` 指针组成双端链表， 如图 3-1 所示。

![digraph](img/graphviz-5f4d8b6177061ac52d0ae05ef357fceb52e9cb901.png)

虽然仅仅使用多个 `listNode` 结构就可以组成链表， 但使用 `adlist.h/list` 来持有链表的话， 操作起来会更方便：

```
typedef struct list {

    // 表头节点
    listNode *head;

    // 表尾节点
    listNode *tail;

    // 链表所包含的节点数量
    unsigned long len;

    // 节点值复制函数
    void *(*dup)(void *ptr);

    // 节点值释放函数
    void (*free)(void *ptr);

    // 节点值对比函数
    int (*match)(void *ptr, void *key);

} list;
```

`list` 结构为链表提供了表头指针 `head` 、表尾指针 `tail` ， 以及链表长度计数器 `len` ， 而 `dup` 、 `free` 和 `match` 成员则是用于实现多态链表所需的类型特定函数：

- `dup` 函数用于复制链表节点所保存的值；
- `free` 函数用于释放链表节点所保存的值；
- `match` 函数则用于对比链表节点所保存的值和另一个输入值是否相等。

图 3-2 是由一个 `list` 结构和三个 `listNode` 结构组成的链表：

![digraph](img/graphviz-5f4d8b6177061ac52d0ae05ef357fceb52e9cb90.png)

Redis 的链表实现的特性可以总结如下：

- 双端： 链表节点带有 `prev` 和 `next` 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) 。
- 无环： 表头节点的 `prev` 指针和表尾节点的 `next` 指针都指向 `NULL` ， 对链表的访问以 `NULL` 为终点。
- 带表头指针和表尾指针： 通过 `list` 结构的 `head` 指针和 `tail` 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。
- 带链表长度计数器： 程序使用 `list` 结构的 `len` 属性来对 `list` 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。
- 多态： 链表节点使用 `void*` 指针来保存节点值， 并且可以通过 `list` 结构的 `dup` 、 `free` 、 `match` 三个属性为节点值设置类型特定函数， 
所以链表可以用于保存各种不同类型的值。

表 3-1 列出了所有用于操作链表和链表节点的 API 。

------

表 3-1 链表和链表节点 API

| 函数                 | 作用                                                         | 时间复杂度                                           |
| :------------------- | :----------------------------------------------------------- | :--------------------------------------------------- |
| `listSetDupMethod`   | 将给定的函数设置为链表的节点值复制函数。                     | O(1) 。                                              |
| `listGetDupMethod`   | 返回链表当前正在使用的节点值复制函数。                       | 复制函数可以通过链表的 `dup` 属性直接获得， O(1)     |
| `listSetFreeMethod`  | 将给定的函数设置为链表的节点值释放函数。                     | O(1) 。                                              |
| `listGetFree`        | 返回链表当前正在使用的节点值释放函数。                       | 释放函数可以通过链表的 `free` 属性直接获得， O(1)    |
| `listSetMatchMethod` | 将给定的函数设置为链表的节点值对比函数。                     | O(1)                                                 |
| `listGetMatchMethod` | 返回链表当前正在使用的节点值对比函数。                       | 对比函数可以通过链表的 `match` 属性直接获得， O(1)   |
| `listLength`         | 返回链表的长度（包含了多少个节点）。                         | 链表长度可以通过链表的 `len` 属性直接获得， O(1) 。  |
| `listFirst`          | 返回链表的表头节点。                                         | 表头节点可以通过链表的 `head` 属性直接获得， O(1) 。 |
| `listLast`           | 返回链表的表尾节点。                                         | 表尾节点可以通过链表的 `tail` 属性直接获得， O(1) 。 |
| `listPrevNode`       | 返回给定节点的前置节点。                                     | 前置节点可以通过节点的 `prev` 属性直接获得， O(1) 。 |
| `listNextNode`       | 返回给定节点的后置节点。                                     | 后置节点可以通过节点的 `next` 属性直接获得， O(1) 。 |
| `listNodeValue`      | 返回给定节点目前正在保存的值。                               | 节点值可以通过节点的 `value` 属性直接获得， O(1) 。  |
| `listCreate`         | 创建一个不包含任何节点的新链表。                             | O(1)                                                 |
| `listAddNodeHead`    | 将一个包含给定值的新节点添加到给定链表的表头。               | O(1)                                                 |
| `listAddNodeTail`    | 将一个包含给定值的新节点添加到给定链表的表尾。               | O(1)                                                 |
| `listInsertNode`     | 将一个包含给定值的新节点添加到给定节点的之前或者之后。       | O(1)                                                 |
| `listSearchKey`      | 查找并返回链表中包含给定值的节点。                           | O(N) ， `N` 为链表长度。                             |
| `listIndex`          | 返回链表在给定索引上的节点。                                 | O(N) ， `N` 为链表长度。                             |
| `listDelNode`        | 从链表中删除给定节点。                                       | O(1) 。                                              |
| `listRotate`         | 将链表的表尾节点弹出，然后将被弹出的节点插入到链表的表头， 成为新的表头节点。 | O(1)                                                 |
| `listDup`            | 复制一个给定链表的副本。                                     | O(N) ， `N` 为链表长度。                             |
| `listRelease`        | 释放给定链表，以及链表中的所有节点。                         | O(N) ， `N` 为链表长度。                             |

------

### 重点回顾

- 链表被广泛用于实现 Redis 的各种功能， 比如列表键， 发布与订阅， 慢查询， 监视器， 等等。
- 每个链表节点由一个 `listNode` 结构来表示， 每个节点都有一个指向前置节点和后置节点的指针， 所以 Redis 的链表实现是双端链表。
- 每个链表使用一个 `list` 结构来表示， 这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。
- 因为链表表头节点的前置节点和表尾节点的后置节点都指向 `NULL` ， 所以 Redis 的链表实现是无环链表。
- 通过为链表设置不同的类型特定函数， Redis 的链表可以用于保存各种不同类型的值。

