## 快速排序算法



冒泡排序可以说是我们学习第一个真正的排序算法，并且解决了桶排序浪费空间的问题，但在算法的执行效率上却牺牲了很多，它的时间复杂度达到了 **O(N2)**。假如我们的计算机每秒钟可以运行 **10** 亿次，那么对 **1** 亿个数进行排序，桶排序则只需要 **0.1** 秒，而冒泡排序则需要 **1** 千万秒，达到 **115** 天之久，是不是很吓人。那有没有既不浪费空间又可以快一点的排序算法呢？那就是“快速排序”啦！光听这个名字是不是就觉得很高端呢。

假设我们现在对“**6 1 2 7 9 3 4 5 10 8**”这个 10 个数进行排序。首先在这个序列中随便找一个数作为基准数（不要被这个名词吓到了，就是一个用来参照的数，待会你就知道它用来做啥的了）。为了方便，就让第一个数 **6** 作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在 **6** 的右边，比基准数小的数放在 **6** 的左边，类似下面这种排列。

3 1 2 5 4 **6** 9 7 10 8

在初始状态下，数字 **6** 在序列的第 **1** 位。我们的目标是将 **6** 挪到序列中间的某个位置，假设这个位置是 **k**。现在就需要寻找这个 **k**，并且以第 **k** 位为分界点，左边的数都小于等于 **6**，右边的数都大于等于 **6**。想一想，你有办法可以做到这点吗？

给你一个提示吧。请回忆一下冒泡排序，是如何通过“交换”，一步步让每个数归位的。此时你也可以通过“交换”的方法来达到目的。具体是如何一步步交换呢？怎样交换才既方便又节省时间呢？先别急着往下看，拿出笔来，在纸上画画看。我高中时第一次学习冒泡排序算法的时候，就觉得冒泡排序很浪费时间，每次都只能对相邻的两个数进行比较，这显然太不合理了。于是我就想了一个办法，后来才知道原来这就是“快速排序”，请允许我小小的自恋一下(^o^)。

方法其实很简单：分别从初始序列“**6 1 2 7 9 3 4 5 10 8**”两端开始“探测”。先从**右**往**左**找一个小于 **6** 的数，再从**左**往**右**找一个大于 **6** 的数，然后交换他们。这里可以用两个变量 **i** 和 **j**，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵 i”和“哨兵 j”。刚开始的时候让哨兵 i 指向序列的最左边（即 **i=1**），指向数字 **6**。让哨兵 **j** 指向序列的最右边（即 **j=10**），指向数字 **8**。

![picture3.1](img/3.1.png)

首先哨兵 **j** 开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵 **j** 先出动，这一点非常重要（请自己想一想为什么）。哨兵 **j** 一步一步地向左挪动（即 **j--**），直到找到一个小于 **6** 的数停下来。接下来哨兵 **i** 再一步一步向右挪动（即 **i++**），直到找到一个数大于 **6** 的数停下来。最后哨兵 **j** 停在了数字 **5** 面前，哨兵 **i** 停在了数字 **7** 面前。

![picture3.2](img/3.2.png)

![picture3.3](img/3.3.png)

现在交换哨兵 **i** 和哨兵 **j** 所指向的元素的值。交换之后的序列如下。

6 1 2 **5** 9 3 4 **7** 10 8

![picture3.4](img/3.4.png)

![picture3.5](img/3.5.png)

到此，第一次交换结束。接下来开始哨兵 **j** 继续向左挪动（再友情提醒，每次必须是哨兵 **j** 先出发）。他发现了 **4**（比基准数 **6** 要小，满足要求）之后停了下来。哨兵 **i** 也继续向右挪动的，他发现了 **9**（比基准数 **6** 要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下。

6 1 2 5 **4** 3 **9** 7 10 8

第二次交换结束，“探测”继续。哨兵 **j** 继续向左挪动，他发现了 **3**（比基准数 **6** 要小，满足要求）之后又停了下来。哨兵 **i** 继续向右移动，糟啦！此时哨兵 **i** 和哨兵 **j** 相遇了，哨兵 **i** 和哨兵 **j** 都走到 **3** 面前。说明此时“探测”结束。我们将基准数 **6** 和 **3** 进行交换。交换之后的序列如下。

**3** 1 2 5 4 **6** 9 7 10 8

![picture3.6](img/3.6.png)

![picture3.7](img/3.7.png)

![picture3.8](img/3.8.png)

到此第一轮“探测”真正结束。此时以基准数 **6** 为分界点，**6** 左边的数都小于等于 **6**，**6** 右边的数都大于等于 **6**。回顾一下刚才的过程，其实哨兵 **j** 的使命就是要找小于基准数的数，而哨兵 **i** 的使命就是要找大于基准数的数，直到 **i** 和 **j** 碰头为止。

OK，解释完毕。现在基准数 **6** 已经归位，它正好处在序列的第 **6** 位。此时我们已经将原来的序列，以 **6** 为分界点拆分成了两个序列，左边的序列是“**3 1 2 5 4**”，右边的序列是“ **9 7 10 8** ”。接下来还需要分别处理这两个序列。因为 **6** 左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理 **6** 左边和右边的序列即可。现在先来处理 **6** 左边的序列现吧。

左边的序列是“**3 1 2 5 4**”。请将这个序列以 **3** 为基准数进行调整，使得 **3** 左边的数都小于等于 **3**，**3** 右边的数都大于等于 **3**。好了开始动笔吧。

如果你模拟的没有错，调整完毕之后的序列的顺序应该是。

2 1 **3** 5 4

OK，现在 **3** 已经归位。接下来需要处理 **3** 左边的序列“ **2 1** ”和右边的序列“**5 4**”。对序列“ **2 1** ”以 **2** 为基准数进行调整，处理完毕之后的序列为“**1 2**”，到此 **2** 已经归位。序列“**1**”只有一个数，也不需要进行任何处理。至此我们对序列“ **2 1** ”已全部处理完毕，得到序列是“**1 2**”。序列“**5 4**”的处理也仿照此方法，最后得到的序列如下。

1 2 3 4 5 6 9 7 10 8

对于序列“**9 7 10 8**”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下。

1 2 3 4 5 6 7 8 9 10

到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。

![picture3.9](img/3.9.png)

快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是 **O(N2)**，它的平均时间复杂度为 **O(NlogN)**。其实快速排序是基于一种叫做“二分”的思想。我们后面还会遇到“二分”思想，到时候再聊。先上代码，如下。

```java
    /**
     * 实现排序
     * @param array 原数据
     * @param begin 起始位置
     * @param end   截至位置
     */
    static void sort(int[] array,int begin,int end){
        //1. 开始(i)和末尾(j)的没有相遇之前比较各个元素与基准值的大小
        if(begin < end){
            //选择基准数
            int base = array[begin];
            // 左标记
            int i = begin;
            //右标记
            int j = end;
            while (i < j){
                //从左往右 元素比基准数大
                while (i < j && array[j] > base){
                    //右标记 -- ，直到找到第一个比基准数小的
                    j--;
                }
                if(i < j){
                    //交换右扫描第一个基准数小的
                   array[i]=array[j];
                   //i标记右移一位
                   i++;
                }
                System.out.println(Arrays.toString(array));
                //从左往右扫描
                while (i < j && array[i] < base){
                    //左侧标记++，直到找到第一个比基准值大的，停止扫描
                    i++;
                }
                if(i < j){
                    //交换左扫描第一个比基准数值大的数
                   array[j] = array[i];
                   j--; // j 标记左移一位
                }
                System.out.println(Arrays.toString(array));
            }// 此时基准值左右两侧相对有序
            //此时i为中间位置，此时说明已经相遇
            array[i] = base;
            //左侧按照快排序的思路
            sort(array,begin,i-1);
            //右侧按照快排序的思路
            sort(array,i+1,end);
        }
    }

    public static void main(String[] args) {
        int[] array = new int[]{10,3,7,9,12,4,2};
        sort(array,0,array.length-1);
        System.out.println(Arrays.toString(array));
    }
```